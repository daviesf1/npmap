/**
 * wax - 7.0.0dev13 - v6.0.4-142-ga157a2d
 */
var html4={atype:{NONE:0,URI:1,URI_FRAGMENT:11,SCRIPT:2,STYLE:3,ID:4,IDREF:5,IDREFS:6,GLOBAL_NAME:7,LOCAL_NAME:8,CLASSES:9,FRAME_TARGET:10},ATTRIBS:{"*::class":9,"*::dir":0,"*::id":4,"*::lang":0,"*::onclick":2,"*::ondblclick":2,"*::onkeydown":2,"*::onkeypress":2,"*::onkeyup":2,"*::onload":2,"*::onmousedown":2,"*::onmousemove":2,"*::onmouseout":2,"*::onmouseover":2,"*::onmouseup":2,"*::style":3,"*::title":0,"a::accesskey":0,"a::coords":0,"a::href":1,"a::hreflang":0,"a::name":7,"a::onblur":2,"a::onfocus":2,"a::rel":0,"a::rev":0,"a::shape":0,"a::tabindex":0,"a::target":10,"a::type":0,"area::accesskey":0,"area::alt":0,"area::coords":0,"area::href":1,"area::nohref":0,"area::onblur":2,"area::onfocus":2,"area::shape":0,"area::tabindex":0,"area::target":10,"bdo::dir":0,"blockquote::cite":1,"br::clear":0,"button::accesskey":0,"button::disabled":0,"button::name":8,"button::onblur":2,"button::onfocus":2,"button::tabindex":0,"button::type":0,"button::value":0,"canvas::height":0,"canvas::width":0,"caption::align":0,"col::align":0,"col::char":0,"col::charoff":0,"col::span":0,"col::valign":0,"col::width":0,"colgroup::align":0,"colgroup::char":0,"colgroup::charoff":0,"colgroup::span":0,"colgroup::valign":0,"colgroup::width":0,"del::cite":1,"del::datetime":0,"dir::compact":0,"div::align":0,"dl::compact":0,"font::color":0,"font::face":0,"font::size":0,"form::accept":0,"form::action":1,"form::autocomplete":0,"form::enctype":0,"form::method":0,"form::name":7,"form::onreset":2,"form::onsubmit":2,"form::target":10,"h1::align":0,"h2::align":0,"h3::align":0,"h4::align":0,"h5::align":0,"h6::align":0,"hr::align":0,"hr::noshade":0,"hr::size":0,"hr::width":0,"iframe::align":0,"iframe::frameborder":0,"iframe::height":0,"iframe::marginheight":0,"iframe::marginwidth":0,"iframe::width":0,"img::align":0,"img::alt":0,"img::border":0,"img::height":0,"img::hspace":0,"img::ismap":0,"img::name":7,"img::src":1,"img::usemap":11,"img::vspace":0,"img::width":0,"input::accept":0,"input::accesskey":0,"input::align":0,"input::alt":0,"input::autocomplete":0,"input::checked":0,"input::disabled":0,"input::ismap":0,"input::maxlength":0,"input::name":8,"input::onblur":2,"input::onchange":2,"input::onfocus":2,"input::onselect":2,"input::readonly":0,"input::size":0,"input::src":1,"input::tabindex":0,"input::type":0,"input::usemap":11,"input::value":0,"ins::cite":1,"ins::datetime":0,"label::accesskey":0,"label::for":5,"label::onblur":2,"label::onfocus":2,"legend::accesskey":0,"legend::align":0,"li::type":0,"li::value":0,"map::name":7,"menu::compact":0,"ol::compact":0,"ol::start":0,"ol::type":0,"optgroup::disabled":0,"optgroup::label":0,"option::disabled":0,"option::label":0,"option::selected":0,"option::value":0,"p::align":0,"pre::width":0,"q::cite":1,"select::disabled":0,"select::multiple":0,"select::name":8,"select::onblur":2,"select::onchange":2,"select::onfocus":2,"select::size":0,"select::tabindex":0,"table::align":0,"table::bgcolor":0,"table::border":0,"table::cellpadding":0,"table::cellspacing":0,"table::frame":0,"table::rules":0,"table::summary":0,"table::width":0,"tbody::align":0,"tbody::char":0,"tbody::charoff":0,"tbody::valign":0,"td::abbr":0,"td::align":0,"td::axis":0,"td::bgcolor":0,"td::char":0,"td::charoff":0,"td::colspan":0,"td::headers":6,"td::height":0,"td::nowrap":0,"td::rowspan":0,"td::scope":0,"td::valign":0,"td::width":0,"textarea::accesskey":0,"textarea::cols":0,"textarea::disabled":0,"textarea::name":8,"textarea::onblur":2,"textarea::onchange":2,"textarea::onfocus":2,"textarea::onselect":2,"textarea::readonly":0,"textarea::rows":0,"textarea::tabindex":0,"tfoot::align":0,"tfoot::char":0,"tfoot::charoff":0,"tfoot::valign":0,"th::abbr":0,"th::align":0,"th::axis":0,"th::bgcolor":0,"th::char":0,"th::charoff":0,"th::colspan":0,"th::headers":6,"th::height":0,"th::nowrap":0,"th::rowspan":0,"th::scope":0,"th::valign":0,"th::width":0,"thead::align":0,"thead::char":0,"thead::charoff":0,"thead::valign":0,"tr::align":0,"tr::bgcolor":0,"tr::char":0,"tr::charoff":0,"tr::valign":0,"ul::compact":0,"ul::type":0},eflags:{OPTIONAL_ENDTAG:1,EMPTY:2,CDATA:4,RCDATA:8,UNSAFE:16,FOLDABLE:32,SCRIPT:64,STYLE:128},ELEMENTS:{a:0,abbr:0,acronym:0,address:0,applet:16,area:2,b:0,base:18,basefont:18,bdo:0,big:0,blockquote:0,body:49,br:2,button:0,canvas:0,caption:0,center:0,cite:0,code:0,col:2,colgroup:1,dd:1,del:0,dfn:0,dir:0,div:0,dl:0,dt:1,em:0,fieldset:0,font:0,form:0,frame:18,frameset:16,h1:0,h2:0,h3:0,h4:0,h5:0,h6:0,head:49,hr:2,html:49,i:0,iframe:4,img:2,input:2,ins:0,isindex:18,kbd:0,label:0,legend:0,li:1,link:18,map:0,menu:0,meta:18,nobr:0,noembed:4,noframes:20,noscript:20,object:16,ol:0,optgroup:0,option:1,p:1,param:18,pre:0,q:0,s:0,samp:0,script:84,select:0,small:0,span:0,strike:0,strong:0,style:148,sub:0,sup:0,table:0,tbody:1,td:1,textarea:8,tfoot:1,th:1,thead:1,title:24,tr:1,tt:0,u:0,ul:0,"var":0},ueffects:{NOT_LOADED:0,SAME_DOCUMENT:1,NEW_DOCUMENT:2},URIEFFECTS:{"a::href":2,"area::href":2,"blockquote::cite":0,"body::background":1,"del::cite":0,"form::action":2,"img::src":1,"input::src":1,"ins::cite":0,"q::cite":0},ltypes:{UNSANDBOXED:2,SANDBOXED:1,DATA:0},LOADERTYPES:{"a::href":2,"area::href":2,"blockquote::cite":2,"body::background":1,"del::cite":2,"form::action":2,"img::src":1,"input::src":1,"ins::cite":2,"q::cite":2}},html=function(a){function c(a,d){var b;b=g(d);if(k.hasOwnProperty(b))b=k[b];else{var c=b.match(q);b=c?String.fromCharCode(parseInt(c[1],10)):(c=b.match(m))?String.fromCharCode(parseInt(c[1],16)):""}return b}function e(a){return a.replace(t,c)}function f(a){return a.replace(v,"&amp;").replace(j,"&lt;").replace(n,"&gt;").replace(x,"&#34;").replace(y,"&#61;")}function d(a){return a.replace(u,"&amp;$1").replace(j,"&lt;").replace(n,"&gt;")}function b(b){return function(c,f){c=String(c);var j=null,h=!1,k=[],r=void 0,m=void 0,w=void 0;for(b.startDoc&&b.startDoc(f);c;){var l=c.match(h?z:A);c=c.substring(l[0].length);if(h)if(l[1]){var n=g(l[1]);if(l[2]){l=l[3];switch(l.charCodeAt(0)){case 34:case 39:l=l.substring(1,l.length-1)}l=e(l.replace(p,""))}else l=n;k.push(n,l)}else l[4]&&(void 0!==m&&(w?b.startTag&&b.startTag(r,k,f):b.endTag&&b.endTag(r,f)),w&&m&(a.eflags.CDATA|a.eflags.RCDATA)&&(j=null===j?g(c):j.substring(j.length-c.length),h=j.indexOf("</"+r),0>h&&(h=c.length),h&&(m&a.eflags.CDATA?b.cdata&&b.cdata(c.substring(0,h),f):b.rcdata&&b.rcdata(d(c.substring(0,h)),f),c=c.substring(h))),r=m=w=void 0,k.length=0,h=!1);else l[1]?b.pcdata&&b.pcdata(l[0],f):l[3]?(w=!l[2],h=!0,r=g(l[3]),m=a.ELEMENTS.hasOwnProperty(r)?a.ELEMENTS[r]:void 0):l[4]?b.pcdata&&b.pcdata(l[4],f):l[5]&&b.pcdata&&(n=l[5],b.pcdata("<"===n?"&lt;":">"===n?"&gt;":"&amp;",f))}b.endDoc&&b.endDoc(f)}}function h(c){var d,e;return b({startDoc:function(){d=[];e=!1},startTag:function(b,j,h){if(!e&&a.ELEMENTS.hasOwnProperty(b)){var g=a.ELEMENTS[b];if(!(g&a.eflags.FOLDABLE))if(g&a.eflags.UNSAFE)e=!(g&a.eflags.EMPTY);else if(j=c(b,j)){g&a.eflags.EMPTY||d.push(b);h.push("<",b);b=0;for(g=j.length;b<g;b+=2){var k=j[b],m=j[b+1];null!==m&&void 0!==m&&h.push(" ",k,'="',f(m),'"')}h.push(">")}}},endTag:function(b,c){if(e)e=!1;else if(a.ELEMENTS.hasOwnProperty(b)){var f=a.ELEMENTS[b];if(!(f&(a.eflags.UNSAFE|a.eflags.EMPTY|a.eflags.FOLDABLE))){if(f&a.eflags.OPTIONAL_ENDTAG)for(f=d.length;0<=--f;){var j=d[f];if(j===b)break;if(!(a.ELEMENTS[j]&a.eflags.OPTIONAL_ENDTAG))return}else for(f=d.length;0<=--f&&d[f]!==b;);if(!(0>f)){for(var g=d.length;--g>f;)j=d[g],a.ELEMENTS[j]&a.eflags.OPTIONAL_ENDTAG||c.push("</",j,">");d.length=f;c.push("</",b,">")}}}},pcdata:function(a,b){e||b.push(a)},rcdata:function(a,b){e||b.push(a)},cdata:function(a,b){e||b.push(a)},endDoc:function(a){for(var b=d.length;0<=--b;)a.push("</",d[b],">");d.length=0}})}var g;g=function(a){return a.toLowerCase()};var k={lt:"<",gt:">",amp:"&",nbsp:"\u00a0",quot:'"',apos:"'"},s=/^(?:https?|mailto|data)$/i,q=/^#(\d+)$/,m=/^#x([0-9A-Fa-f]+)$/,p=/\0/g,t=/&(#\d+|#x[0-9A-Fa-f]+|\w+);/g,v=/&/g,u=/&([^a-z#]|#(?:[^0-9x]|x(?:[^0-9a-f]|$)|$)|$)/gi,j=/</g,n=/>/g,x=/\"/g,y=/\=/g,z=RegExp("^\\s*(?:(?:([a-z][a-z-]*)(\\s*=\\s*(\"[^\"]*\"|'[^']*'|(?=[a-z][a-z-]*\\s*=)|[^>\"'\\s]*))?)|(/?>)|[\\s\\S][^a-z\\s>]*)","i"),A=RegExp("^(?:&(\\#[0-9]+|\\#[x][0-9a-f]+|\\w+);|\x3c!--[\\s\\S]*?--\x3e|<!\\w[^>]*>|<\\?[^>*]*>|<(/)?([a-z][a-z0-9]*)|([^<&>]+)|([<&>]))","i"),B=/^(?:([^:/?#]+):)?/;return{escapeAttrib:f,makeHtmlSanitizer:h,makeSaxParser:b,normalizeRCData:d,sanitize:function(b,d,c){var f=[];h(function(b,f){for(var j=0;j<f.length;j+=2){var e=f[j],g=f[j+1],h=null,k;if((k=b+"::"+e,a.ATTRIBS.hasOwnProperty(k))||(k="*::"+e,a.ATTRIBS.hasOwnProperty(k)))h=a.ATTRIBS[k];if(null!==h)switch(h){case a.atype.NONE:break;case a.atype.SCRIPT:case a.atype.STYLE:g=null;break;case a.atype.ID:case a.atype.IDREF:case a.atype.IDREFS:case a.atype.GLOBAL_NAME:case a.atype.LOCAL_NAME:case a.atype.CLASSES:g=c?c(g):g;break;case a.atype.URI:g=(e=(""+g).match(B))?!e[1]||s.test(e[1])?d&&d(g):null:null;break;case a.atype.URI_FRAGMENT:g&&"#"===g.charAt(0)?(g=c?c(g):g)&&(g="#"+g):g=null;break;default:g=null}else g=null;f[j+1]=g}return f})(b,f);return f.join("")},unescapeEntities:e}}(html4),html_sanitize=html.sanitize;"undefined"!==typeof window&&(window.html=html,window.html_sanitize=html_sanitize);html4.ATTRIBS["*::style"]=0;html4.ELEMENTS.style=0;html4.ATTRIBS["a::target"]=0;html4.ELEMENTS.video=0;html4.ATTRIBS["video::src"]=0;html4.ATTRIBS["video::poster"]=0;html4.ATTRIBS["video::controls"]=0;html4.ELEMENTS.audio=0;html4.ATTRIBS["audio::src"]=0;html4.ATTRIBS["video::autoplay"]=0;html4.ATTRIBS["video::controls"]=0;wax={bwdetect:function(a,c){var e={},f=a.threshold||400,d="http://a.tiles.mapbox.com/mapbox/1.0.0/blue-marble-topo-bathy-jul/0/0/0.png?preventcache="+ +new Date,b=1,h=void 0===a.auto?!0:a.auto;e.bw=function(a){if(!arguments.length)return b;if(wax.bwlisteners&&wax.bwlisteners.length){listeners=wax.bwlisteners;wax.bwlisteners=[];for(i=0;i<listeners;i++)listeners[i](a)}wax.bw=a;b!=(b=a)&&c(a)};e.add=function(){if(h){wax.bw=-1;var a=new Image;a.src=d;var b=!0,c=setTimeout(function(){b&&-1==wax.bw&&(e.bw(0),b=!1)},f);a.onload=function(){b&&-1==wax.bw&&(clearTimeout(c),e.bw(1),b=!1)}}return this};-1==wax.bw?(wax.bwlisteners=wax.bwlisteners||[],wax.bwlisteners.push(e.bw)):void 0!==wax.bw?e.bw(wax.bw):e.add();return e},formatter:function(a){var c={},e;if(a&&"string"===typeof a)try{eval("f = "+a)}catch(f){console&&console.log(f)}else e=a&&"function"===typeof a?a:function(){};c.format=function(a,b){try{return wax.u.sanitize(e(a,b))}catch(c){console&&console.log(c)}};return c},gi:function(a,c){c=c||{};var e={},f=c.resolution||4,d=c.tileSize||256;e.grid_tile=function(){return a};e.getKey=function(b,c){if(a&&a.grid&&!(0>c||0>b))if(!(Math.floor(c)>=d||Math.floor(b)>=d)){var e=a.grid[Math.floor(c/f)].charCodeAt(Math.floor(b/f));93<=e&&e--;35<=e&&e--;return e-32}};e.gridFeature=function(b,c){var d=this.getKey(b,c),f=a.keys;if(f&&f[d]&&a.data[f[d]])return a.data[f[d]]};e.tileFeature=function(b,c,d){if(a)return d=wax.u.offset(d),feature=this.gridFeature(b-d.left,c-d.top)};return e},gm:function(){var a=4,c={},e,f,d=function(a){if(a)return a.replace(/(\.png|\.jpg|\.jpeg)(\d*)/,".grid.json")};c.formatter=function(a){if(!arguments.length)return f;f=wax.formatter(a);return c};c.template=function(a){if(!arguments.length)return f;f=wax.template(a);return c};c.gridUrl=function(a){if(!arguments.length)return d;if(a){var f;if("function"===typeof a)f=a;else{var e=a;"string"===typeof e&&(e=[e]);f=function(a){if(a&&(a=/\/(\d+)\/(\d+)\/(\d+)\.[\w\._]+/.exec(a)))return e[parseInt(a[2],10)%e.length].replace(/\{z\}/g,a[1]).replace(/\{x\}/g,a[2]).replace(/\{y\}/g,a[3])}}d=f}else d=function(){return null};return c};c.getGrid=function(b,e){var g=d(b);if(!f||!g)return e(null,null);wax.request.get(g,function(b,c){if(b)return e(b,null);e(null,wax.gi(c,{formatter:f,resolution:a}))});return c};c.tilejson=function(b){if(!arguments.length)return e;b.template?c.template(b.template):b.formatter?c.formatter(b.formatter):f=void 0;c.gridUrl(b.grids);b.resolution&&(a=b.resolution);e=b;return c};return c},interaction:function(){function a(){b=!1}function c(c){b=!0;g=wax.u.eventoffset(c);"mousedown"===c.type?(bean.add(document.body,"click",e),bean.add(document.body,"mouseup",a)):"touchstart"===c.type&&1===c.touches.length&&(bean.fire(d,"off"),bean.add(c.srcElement,u))}function e(a){var c={},f=wax.u.eventoffset(a);b=!1;for(var m in a)c[m]=a[m];bean.remove(document.body,"mouseup",e);bean.remove(a.srcElement,u);"touchend"===a.type?d.click(a,g):Math.round(f.y/k)===Math.round(g.y/k)&&Math.round(f.x/k)===Math.round(g.x/k)&&(h?h&&(window.clearTimeout(h),h=null):h=window.setTimeout(function(){h=null;d.click(c,f)},300));return e}var f=wax.gm(),d={},b=!1,h=null,g,k=4,s,q,m,p,t,v={mousemove:function(a){if(!b){var c=wax.u.eventoffset(a);d.screen_feature(c,function(b){b?bean.fire(d,"on",{parent:p(),data:b,formatter:f.formatter().format,e:a}):bean.fire(d,"off")})}},touchstart:c,mousedown:c},u={touchend:e,touchmove:e,touchcancel:function(a){bean.remove(a.srcElement,u);b=!1}};d.click=function(a,b){d.screen_feature(b,function(b){b&&bean.fire(d,"on",{parent:p(),data:b,formatter:f.formatter().format,e:a})})};d.screen_feature=function(a,b){var c;a:{for(var d=s(),e=0;e<d.length;e++)if(d[e][0]<a.y&&d[e][0]+256>a.y&&d[e][1]<a.x&&d[e][1]+256>a.x){c=d[e][2];break a}c=!1}c||b(null);f.getGrid(c.src,function(d,f){if(d||!f)return b(null);var e=f.tileFeature(a.x,a.y,c);b(e)})};d.attach=function(a){if(!arguments.length)return q;q=a;return d};d.detach=function(a){if(!arguments.length)return m;m=a;return d};d.map=function(a){if(!arguments.length)return t;t=a;q&&q(t);bean.add(p(),v);bean.add(p(),"touchstart",c);return d};d.grid=function(a){if(!arguments.length)return s;s=a;return d};d.remove=function(){m&&m(t);bean.remove(p(),v);bean.fire(d,"remove");return d};d.tilejson=function(a){if(!arguments.length)return f.tilejson();f.tilejson(a);return d};d.formatter=function(){return f.formatter()};d.on=function(a,b){bean.add(d,a,b);return d};d.off=function(a,b){bean.remove(d,a,b);return d};d.gridmanager=function(a){if(!arguments.length)return f;f=a;return d};d.parent=function(a){p=a;return d};return d},legend:function(){var a,c={},e;c.element=function(){return e};c.content=function(f){if(!arguments.length)return a.innerHTML;a.innerHTML=wax.u.sanitize(f);a.style.display="block";""===a.innerHTML&&(a.style.display="none");return c};c.add=function(){e=document.createElement("div");e.className="map-legends wax-legends";a=e.appendChild(document.createElement("div"));a.className="map-legend wax-legend";a.style.display="none";return c};return c.add()},location:function(){function a(a){if("mousemove"!==a.e.type&&a.e.type&&(a=a.formatter({format:"location"},a.data)))window.top.location.href=a}return{events:function(){return{on:a}}}},request:{cache:{},locks:{},promises:{},get:function(a,c){if(this.cache[a])return c(this.cache[a][0],this.cache[a][1]);this.promises[a]=this.promises[a]||[];this.promises[a].push(c);if(!this.locks[a]){var e=this;this.locks[a]=!0;reqwest({url:a+(~a.indexOf("?")?"&":"?")+"callback=?",type:"jsonp",success:function(c){e.locks[a]=!1;e.cache[a]=[null,c];for(c=0;c<e.promises[a].length;c++)e.promises[a][c](e.cache[a][0],e.cache[a][1])},error:function(c){e.locks[a]=!1;e.cache[a]=[c,null];for(c=0;c<e.promises[a].length;c++)e.promises[a][c](e.cache[a][0],e.cache[a][1])}})}}},template:function(a){return{format:function(c,e){var f={},d;for(d in e)f[d]=e[d];c.format&&(f["__"+c.format+"__"]=!0);return wax.u.sanitize(Mustache.to_html(a,f))}}}};if(!wax)var wax={};wax.tilejson=function(a,c){reqwest({url:a+(~a.indexOf("?")?"&":"?")+"callback=?",type:"jsonp",success:c,error:c})};wax.u={offset:function(a){var c=a.offsetWidth||parseInt(a.style.width,10),e=a.offsetHeight||parseInt(a.style.height,10),f=document.body,d=0,b=0,h=function(a){if(!(a===f||a===document.documentElement))if(d+=a.offsetTop,b+=a.offsetLeft,a=a.style.transform||a.style.WebkitTransform||a.style.OTransform||a.style.MozTransform||a.style.msTransform){var c;if(c=a.match(/translate\((.+)[px]?, (.+)[px]?\)/))d+=parseInt(c[2],10),b+=parseInt(c[1],10);else if(c=a.match(/translate3d\((.+)[px]?, (.+)[px]?, (.+)[px]?\)/))d+=parseInt(c[2],10),b+=parseInt(c[1],10);else if(c=a.match(/matrix3d\(([\-\d,\s]+)\)/))a=c[1].split(","),d+=parseInt(a[13],10),b+=parseInt(a[12],10);else if(c=a.match(/matrix\(.+, .+, .+, .+, (.+), (.+)\)/))d+=parseInt(c[2],10),b+=parseInt(c[1],10)}};if("undefined"!==typeof a.getBoundingClientRect){var g=document.body,k=a.ownerDocument.documentElement,h=document.clientTop||g.clientTop||0,g=document.clientLeft||g.clientLeft||0,s=window.pageYOffset||k.scrollTop,k=window.pageXOffset||k.scrollLeft;a=a.getBoundingClientRect();d=a.top+s-h;b=a.left+k-g}else{h(a);try{for(;a=a.offsetParent;)h(a)}catch(q){}}d+=f.offsetTop;b+=f.offsetLeft;d+=f.parentNode.offsetTop;b+=f.parentNode.offsetLeft;a=document.defaultView?window.getComputedStyle(f.parentNode,null):f.parentNode.currentStyle;f.parentNode.offsetTop!==parseInt(a.marginTop,10)&&!isNaN(parseInt(a.marginTop,10))&&(d+=parseInt(a.marginTop,10),b+=parseInt(a.marginLeft,10));return{top:d,left:b,height:e,width:c}},$:function(a){return"string"===typeof a?document.getElementById(a):a},eventoffset:function(a){a||(a=window.event);if(a.pageX||a.pageY)return{x:a.pageX,y:a.pageY};if(a.clientX||a.clientY)return{x:a.clientX,y:a.clientY};if(a.touches&&1===a.touches.length)return{x:a.touches[0].pageX,y:a.touches[0].pageY}},limit:function(a,c,e){var f;return function(){var d=this,b=arguments,h=function(){f=null;a.apply(d,b)};e&&clearTimeout(f);if(e||!f)f=setTimeout(h,c)}},throttle:function(a,c){return this.limit(a,c,!1)},sanitize:function(a){return!a?"":html_sanitize(a,function(a){if(/^(https?:\/\/|data:image)/.test(a))return a},function(a){return a})}};

/**
 * @module NPMap.Map
 *
 * The module for all map objects. No "baseApi"-specific code lives here.
 */
define([
  'Event',
  'InfoBox',
  'Util/Util'
], function(Event, InfoBox, Util) {
  var
      // The current API, in lowercase.
      apiLower = NPMap.config.api.toLowerCase(),
      // The attribution div.
      divAttribution = document.createElement('div'),
      // The clickdot div.
      divClickdot = document.createElement('div'),
      /*
      divToolsBottomCenter = document.createElement('div'),
      divToolsBottomLeft = document.createElement('div'),
      divToolsBottomRight = document.createElement('div'),
      divToolsTopCenter = document.createElement('div'),
      divToolsTopLeft = document.createElement('div'),
      divToolsTopRight = document.createElement('div'),
      */
      // The map div.
      divMap = document.getElementById(NPMap.config._div),
      // The notify div.
      divNotify = document.createElement('div'),
      // The npmap div.
      divNpmap = document.getElementById('npmap'),
      // The npmap-controls div.
      //divNpmapControls = document.getElementById('npmap-map-controls'),
      // The parent div.
      divNpmapParent = document.getElementById('npmap').parentNode,
      //
      divOverlay,
      // The npmap-progressbar div.
      divProgressBar = document.createElement('div'),
      // The tip div.
      divTip = document.createElement('div'),
      // The zoombox.
      divZoombox = document.createElement('div'),
      // Does the map have active tile layers?
      hasTiled = false,
      //
      interval,
      // Is the map in fullscreen mode?
      isFullScreen = false,
      // The id of the active mousemove handler.
      mouseMoveId,
      // The pixel object for the current mousedown.
      pixelMouseDown = null,
      // General scales for zoom levels, in meters.
      zoomScales = [
        295829355,
        147914668,
        73957339,
        36978669,
        18489335,
        9244667,
        4622334,
        2311166,
        1155583,
        577792,
        288896,
        144448,
        72224,
        36112,
        18056,
        9028,
        4514,
        2257,
        1128,
        564
      ];

  /**
   * Creates a notify div.
   * @param {String} message
   * @param {String} title (Optional)
   * @param {String} type (Optional)
   * @return {Object}
   */
  function createNotify(message, title, type) {
    var cls = 'content',
        html = '';
        msg = document.createElement('div');

    if (type) {
      cls += ' ' + type;
    }

    msg.className = cls;

    if (title) {
      html += '<h3>' + title + '</h3><p>' + message + '</p>';
    } else {
      html += '<p style="text-align:center;">' + message + '</p>';
    }

    msg.innerHTML = html;

    return msg;
  }
  /**
   * Gets the pixel coordinates of a mouse click event.
   * @param {Object} e
   * @return {Object}
   */
  function getMousePixel(e) {
    var pixel = {
          x: e.clientX,
          y: e.clientY
        },
        position = Util.getOffset(divMap),
        scroll = Util.getScrollPosition(divMap);

    pixel.x = pixel.x - position.left;
    pixel.y = pixel.y - position.top;

    if (!isFullScreen) {
      pixel.x = pixel.x + scroll.left;
      pixel.y = pixel.y + scroll.top;
    }

    return pixel;
  }
  /**
   * Hooks up the click event to an element.
   * @param {String} id
   * @param {Function} func
   * @return {Object}
   */
  function hookUpClickEvent(id, func) {
    var el = document.getElementById(id);
    
    Util.stopAllPropagation(el);
    bean.add(el, 'mouseup', func);

    return el;
  }
  /**
   * Handles the mousemove event for the npmap-zoombox control.
   * @param {Object} e
   * @return null
   */
  function mouseMoveZoomBox(e) {
    var left,
        pixel = getMousePixel(e),
        top;

    divZoombox.style.display = 'block';

    if (pixel.x < pixelMouseDown.x) {
      left = pixel.x;
    } else {
      left = pixelMouseDown.x;
    }

    divZoombox.style.left = left + 'px';
    divZoombox.style.width = Math.abs(pixel.x - pixelMouseDown.x) + 'px';

    if (pixel.y < pixelMouseDown.y) {
      top = pixel.y;
    } else {
      top = pixelMouseDown.y;
    }

    divZoombox.style.height = Math.abs(pixel.y - pixelMouseDown.y) + 'px';
    divZoombox.style.top = top + 'px';
  }
  /**
   * Sets the width of the attribution control based on the width of the map and logos and positions it.
   * @return null
   */
  function setAttributionMaxWidthAndPosition() {
    var divOverviewMap = document.getElementById('npmap-overviewmap'),
        max = Util.getOuterDimensions(divMap).width - Util.getOuterDimensions(document.getElementById('npmap-logos')).width - 40,
        right = 0;

    if (divOverviewMap) {
      var divOverviewMapWidth = Util.getOuterDimensions(divOverviewMap).width;

      max = max - divOverviewMapWidth;
      right = divOverviewMapWidth;
    }
    
    if (max > 0) {
      divAttribution.style.maxWidth = max + 'px';
    }
    
    divAttribution.style.right = right + 'px';
  }

  Event.add('NPMap.Map', 'baselayerchanged', function() {
    NPMap.Map._updateAttribution();
  });
  Event.add('NPMap.Map', 'mousedown', function(e) {
    pixelMouseDown = getMousePixel(e);

    if (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) {
      return false;
    }

    divZoombox.style.display = 'block';
    divZoombox.style.left = pixelMouseDown.x + 'px';
    divZoombox.style.top = pixelMouseDown.y + 'px';
    mouseMoveId = NPMap.Event.add('NPMap.Map', 'mousemove', mouseMoveZoomBox);
    
    NPMap.Map.setCursor('crosshair');
  });
  Event.add('NPMap.Map', 'mouseout', function(e) {
    if (divZoombox.style.display === 'block') {
      divZoombox.style.display = 'none';
      divZoombox.style.height = '0px';
      divZoombox.style.width = '0px';

      NPMap.Map.setCursor('');
      NPMap.Event.remove(mouseMoveId);
      
      pixelMouseDown = null;
    }
  });
  Event.add('NPMap.Map', 'mouseup', function(e) {
    if (divZoombox.style.display === 'block') {
      var pixel = getMousePixel(e),
          coords = {},
          nw,
          se;

      if (pixel.x > pixelMouseDown.x) {
        coords.e = pixel.x;
        coords.w = pixelMouseDown.x;
      } else {
        coords.e = pixelMouseDown.x;
        coords.w = pixel.x;
      }

      if (pixel.y > pixelMouseDown.y) {
        coords.n = pixel.y;
        coords.s = pixelMouseDown.y;
      } else {
        coords.n = pixelMouseDown.y;
        coords.s = pixel.y;
      }

      nw = NPMap.Map.pixelToLatLng({
        x: coords.w,
        y: coords.n
      });
      se = NPMap.Map.pixelToLatLng({
        x: coords.e,
        y: coords.s
      });
      divZoombox.style.display = 'none';
      divZoombox.style.height = '0px';
      divZoombox.style.width = '0px';

      NPMap.Map.toBounds({
        e: se.lng,
        n: nw.lat,
        s: se.lat,
        w: nw.lng
      });
      NPMap.Map.setCursor('');
      NPMap.Event.remove(mouseMoveId);
    }

    pixelMouseDown = null;
  });
  Event.add('NPMap.Map', 'ready', function() {
    var configModules = NPMap.config.modules,
        elements = [],
        htmlLogos = '';

    Event.add('NPMap.Map', 'resized', function() {
      setAttributionMaxWidthAndPosition();
      NPMap.Map._handleResize();
    });
    Util.monitorResize(divMap, function() {
      Event.trigger('NPMap.Map', 'resized');
    });

    divAttribution.id = 'npmap-attribution';
    elements.push({
      el: divAttribution,
      func: function() {
        setAttributionMaxWidthAndPosition();
      }
    });
    divClickdot.id = 'npmap-clickdot';
    elements.push({
      el: divClickdot
    });
    divNotify.id = 'npmap-notify';
    divNotify.style.zIndex = 31;
    elements.push({
      el: divNotify
    });
    divProgressBar.id = 'npmap-progressbar';
    divProgressBar.innerHTML = '<div></div>';
    elements.push({
      el: divProgressBar
    });
    divTip.className = 'padded rounded shadowed transparent';
    divTip.id = 'npmap-tip';
    elements.push({
      el: divTip
    });
    divZoombox.id = 'npmap-zoombox';
    elements.push({
      el: divZoombox,
      stop: false
    });
    
    if (apiLower !== 'leaflet' && apiLower !== 'modestmaps') {
      htmlLogos += '<span style="display:block;float:left;margin-right:8px;"><img src="' + NPMap.config.server + '/resources/img/' + apiLower + 'logo.png" /></span>';
    }
    
    if (NPMap.config.hideLogo !== true) {
      htmlLogos += '<span style="display:block;float:left;"><a href="http://www.nps.gov/npmap" target="_blank"><img src="' + NPMap.config.server + '/resources/img/npmaplogo.png" alt="NPMap - Web Mapping for the U.S. National Park Service" /></a></span>';
    }

    if (htmlLogos.length > 0) {
      // The logo div.
      var logos = document.createElement('div');
      
      logos.id = 'npmap-logos';
      logos.innerHTML = htmlLogos;
      logos.style.cssText = 'bottom:3px;height:30px;left:5px;position:absolute;z-index:30;';
      elements.push({
        el: logos,
        func: function() {
          Util.monitorResize(logos, function() {
            setAttributionMaxWidthAndPosition();
          });
          setAttributionMaxWidthAndPosition();
        }
      });
    }

    if (NPMap.config.baseLayers && NPMap.config.baseLayers.length) {
      var activeIcon = null,
          activeLabel = null,
          items = [];

      _.each(NPMap.config.baseLayers, function(baseLayer) {
        var icon = baseLayer.icon,
            label = baseLayer.name;

        if (typeof baseLayer.name === 'string') {
          if (typeof icon === 'string') {
            baseLayer.icon = NPMap.config.server + '/resources/img/tools/switcher/' + icon + '-small.png';
          } else {
            // TODO: Come up with a default icon.
            baseLayer.icon = NPMap.config.server + '/resources/img/tools/switcher/blank-small.png';
          }

          if (!activeIcon && (typeof baseLayer.visible === 'undefined' || baseLayer.visible === true)) {
            activeIcon = baseLayer.icon;
            activeLabel = baseLayer.name;
          }
          
          items.push(baseLayer);
        }
      });

      if (items.length > 1) {
        var cssSwitcherMenu = 'display:none;max-width:160px;position:absolute;',
            divSwitcher = document.createElement('div'),
            divSwitcherMenu = document.createElement('div'),
            moduleInterfaces = 0;
        
        function setIcon(url) {
          document.getElementById('npmap-switcher-dropdown-icon').innerHTML = '<img src="' + url + '" style="height:15px;margin-top:4.5px;" />';
        }
        function setLabel(text) {
          document.getElementById('npmap-switcher-dropdown-text').innerHTML = text.toUpperCase();
        }

        if (NPMap.config.modules && NPMap.config.modules.length) {
          _.each(NPMap.config.modules, function(module) {
            if (module.name.toLowerCase() !== 'edit') {
              moduleInterfaces++;
            }
          });
        }

        items.sort(function(a, b) {
          return a.name > b.name;
        });

        divSwitcher.className = 'npmap-switcher-dropdown';
        divSwitcher.id = 'npmap-switcher';
        
        if (moduleInterfaces > 0) {
          divSwitcher.style.cssText = 'right:90px;top:30px;'
          cssSwitcherMenu += 'right:90px;top:53px;';
        } else {
          cssSwitcherMenu += 'right:16px;top:38px;';
        }

        divSwitcher.innerHTML = '<div id="npmap-switcher-dropdown-left"></div><div id="npmap-switcher-dropdown-icon"></div><div id="npmap-switcher-dropdown-text"></div><div id="npmap-switcher-dropdown-right"></div>';
        divSwitcherMenu.id = 'npmap-switcher-menu';
        // TODO: Both menus should be able to expand in width up to a set number (maybe 250px?).
        divSwitcherMenu.style.cssText = cssSwitcherMenu;
        
        elements.push({
          el: divSwitcher
        }, {
          el: divSwitcherMenu,
          func: function() {
            var htmlMenu = '<ul>';

            if (activeIcon.length > 0) {
              setIcon(activeIcon);
            }

            if (activeLabel.length > 0) {
              setLabel(activeLabel);
            }

            _.each(items, function(item, i) {
              htmlMenu += '<li class="npmap-switcher-menu-item" style="list-style-type:none;"><a href="javascript:void(0)"><div style="color:#818177;height:28px;line-height:28px;vertical-align:middle;"><div style="float:left;text-align:center;width:35px;"><img src="' + item.icon.replace('small', 'large') + '" style="height:22px;margin-top:3px;"></div><div style="float:right;margin-left:5px;width:100px;">' + item.name + '</div></div></a></li>';
            });
            bean.add(divSwitcher, 'click', function(e) {
              var display = divSwitcherMenu.style.display;

              if (display === '' || display === 'none') {
                divSwitcherMenu.style.display = 'block';
              } else {
                divSwitcherMenu.style.display = 'none';
              }
            });

            divSwitcherMenu.innerHTML = htmlMenu + '</ul>';

            _.each(Util.getElementsByClass('npmap-switcher-menu-item'), function(el, i) {
              bean.add(el, 'click', function(e) {
                var clicked,
                    me = this,
                    currentLabel = me.firstChild.firstChild.childNodes[1].innerHTML;

                if (document.getElementById('npmap-switcher-dropdown-text').innerHTML.toLowerCase() !== currentLabel.toLowerCase()) {
                  for (var i = 0; i < items.length; i++) {
                    var item = items[i];

                    if (item.name === currentLabel) {
                      setIcon(item.icon.replace('large', 'small'));
                      setLabel(item.name);
                      NPMap.Map[NPMap.config.api]._setBaseLayer(item);
                    }
                  }
                }

                divSwitcherMenu.style.display = 'none';
              });
            });
          }
        });
      }
    }

    _.each(elements, function(element) {
      NPMap.Map.addControl(element.el, element.func, element.stop);
    });
  });
  Event.add('NPMap.Map', 'zoomstart', function() {
    if (!NPMap.InfoBox.marker) {
      NPMap.InfoBox.hide();
    }
  });
  bean.add(divMap, 'mouseout', function(e) {
    var el = e.toElement || e.relatedTarget;

    while (el && el.parentNode && el.parentNode != window) {
      if (el.parentNode == this ||  el == this) {
        if (el.preventDefault) {
          el.preventDefault();
        }
        
        return false;
      }
      
      el = el.parentNode;
    }

    Event.trigger('NPMap.Map', 'mouseout', el);
  });

  interval = setInterval(function() {
    if (typeof NPMap.Map === 'object') {
      var Api = NPMap.Map[NPMap.config.api];

      if (typeof Api === 'object' && Api._isReady === true) {
        clearInterval(interval);
        delete Api._isReady;
        NPMap.Map._isReady = true;
        Event.trigger('NPMap.Map', 'ready');
      }
    }
  }, 0);

  return NPMap.Map = {
    //
    _attribution: [],
    /**
     * Adds a tile layer to the map.
     * @param {Object} options
     * @return {Object}
     * Valid options: constructor, name, opacity, zIndex, zoomRange (currently honored by Google and Leaflet)
     */
    _addTileLayer: function(options) {
      options = options || {};

      if (!options.constructor) {
        throw new Error('To add a TileLayer, you must specify the "constructor" property.');
      }

      if (!options.name) {
        throw new Error('To add a TileLayer, you must specify the "name" property.');
      }

      if (options.zoomRange) {
        if (typeof options.zoomRange.max === 'number') {
          options.maxZoom = options.zoomRange.max;
        }

        if (typeof options.zoomRange.min === 'number') {
          options.minZoom = options.zoomRange.min;
        }

        delete options.zoomRange;
      }

      return this[NPMap.config.api]._addTileLayer(options);
    },
    /**
     * Creates a line using the baseApi's line class, if it exists.
     * @param {Array} latLngs An array of the latitude/longitude strings, in "latitude,longitude" format, to use to create the line.
     * @param {Object} options (Optional) Line options.
     * @return {Object}
     */
    _createLine: function(latLngs, options) {
      var apiLatLngs = [],
          line,
          me = this;
      
      _.each(latLngs, function(latLng) {
        apiLatLngs.push(me.latLngToApi(latLng));
      });
      
      line = NPMap.Map[NPMap.config.api].createLine(apiLatLngs, options);
      line.npmap = {
        type: 'Line'
      };

      return line;
    },
    /**
     * Creates a marker using the baseApi's marker class, if it exists.
     * @param {String} latLng The latitude/longitude string, in "latitude,longitude" format, to use to create the marker.
     * @param {Object} options (Optional) Marker options.
     * @return {Object}
     */
    _createMarker: function(latLng, options) {
      var marker = NPMap.Map[NPMap.config.api].createMarker(this.latLngToApi(latLng), options);;

      marker.npmap = {
        type: 'Marker'
      };

      return marker;
    },
    /**
     * Creates a polygon using the baseApi's marker class, if it exists.
     * @param {Array} latLngs An array of latitude/longitude strings, in "latitude,longitude" format, to use to create the polygon.
     * @param {Object} options (Optional) Polygon options.
     * @return {Object}
     */
    _createPolygon: function(latLngs, options) {
      var apiLatLngs = [],
          me = this,
          polygon;

      for (var i = 0; i < latLngs.length; i++) {
        apiLatLngs.push(me.latLngToApi(latLngs[i]));
      }

      polygon = NPMap.Map[NPMap.config.api].createPolygon(apiLatLngs, options);
      polygon.npmap = {
        type: 'Polygon'
      };

      return polygon;
    },
    /**
     * Handles any necessary sizing and positioning for the map when its parent HTML element is resized. You should not need to call this manually.
     * @return null
     */
    _handleResize: function() {
      if (typeof NPMap.Map[NPMap.config.api] !== 'undefined') {
        NPMap.Map[NPMap.config.api].handleResize();
      }
      
      if (NPMap.InfoBox.visible) {
        NPMap.InfoBox.reposition();
      }
    },
    /**
     * Iterates through baseLayers config, setting up visibility and matching baseLayers with an API's default baseLayers.
     * @param {Object} DEFAULT_BASE_LAYERS
     * @return null
     */
    _matchBaseLayers: function(DEFAULT_BASE_LAYERS) {
      var baseLayersMatched = [],
          visibleSet = false

      for (var i = 0; i < NPMap.config.baseLayers.length; i++) {
        var baseLayer = NPMap.config.baseLayers[i],
            matched = DEFAULT_BASE_LAYERS[baseLayer.type.toLowerCase()];

        if (!visibleSet) {
          if (typeof baseLayer.visible === 'undefined' || baseLayer.visible === true) {
            if (matched) {
              matched.visible = true;
            } else {
              baseLayer.visible = true;
            }

            visibleSet = true;
          }
        } else {
          if (matched) {
            matched.visible = false;
          } else {
            baseLayer.visible = false;
          }
        }

        if (matched) {
          baseLayersMatched.push(matched);
        } else {
          baseLayersMatched.push(baseLayer);
        }
      }

      NPMap.config.baseLayers = baseLayersMatched;
    },
    /**
     * Updates the map attribution. Looks at the NPMap.Map._attribution property, the NPMap.Map[NPMap.config.api]._attribution property, and iterates through all of the visible baseLayers and layers and looks at their attribution property as well.
     * @return null
     */
    _updateAttribution: function() {
      var attribution,
          attrs = [],
          disclaimer = '<a href="http://www.nps.gov/npmap/disclaimer.html" target="_blank">Disclaimer</a>',
          me = this;

      if (typeof this._attribution !== 'undefined') {
        _.each(this._attribution, function(v) {
          if (_.indexOf(attrs, v) === -1) {
            attrs.push(v);
          }
        });
      }

      if (typeof this[NPMap.config.api] !== 'undefined' && typeof this[NPMap.config.api]._attribution !== 'undefined') {
        _.each(NPMap.Map[NPMap.config.api]._attribution, function(v) {
          if (_.indexOf(attrs, v) === -1) {
            attrs.push(v);
          }
        });
      }

      if (typeof NPMap.Layer !== 'undefined' && typeof NPMap.Layer.getVisibleLayers === 'function') {
        _.each(NPMap.Layer.getVisibleLayers(), function(layer) {
          if (layer.attribution) {
            var layerAttribution = layer.attribution;

            if (typeof layer.attribution === 'string') {
              layerAttribution = layer.attribution.split('|');
            }

            _.each(layerAttribution, function(v2) {
              var credit = v2.replace(/^\s*/, '').replace(/\s*$/, '');

              if (_.indexOf(attrs, credit) === -1) {
                attrs.push(credit);
              }
            });
          }
        });
      }

      if (attrs.length > 0) {
        attrs.sort();

        attribution = attrs.join(' | ') + ' | ' + disclaimer;
      } else {
        attribution = disclaimer;
      }
      
      divAttribution.innerHTML = attribution;
      divAttribution.style.display = 'block';
    },
    /**
     * Adds an HTML element to the map div.
     * @param {Object} el
     * @param {Function} callback (Optional)
     * @param {Boolean} stopPropagation (Optional)
     * @return null
     */
    addControl: function(el, callback, stopPropagation) {
      var div = NPMap.Map[NPMap.config.api].getMapElement();

      if (el.style.zIndex === '' && el.style.cssText.indexOf('z-index') === -1) {
        el.style.zIndex = '30';
      }

      div.appendChild(el);
      
      if (typeof stopPropagation === 'undefined' || stopPropagation === true) {
        Util.stopAllPropagation(el);
      }

      if (callback) {
        callback();
      }
    },
    /**
     * Adds a shape (marker, line, or polygon) to the map.
     * @param {Object} shape The shape to add to the map. This can be a base API marker, line, or polygon object.
     * @return null
     */
    addShape: function(shape) {
      NPMap.Map[NPMap.config.api].addShape(shape);
    },
    /**
     * Adds an array of shapes (markers, lines, and/or polygons) to the map.
     * @param {Array} shapes The shapes to add to the map. The array can contain base API marker, line, or polygon objects.
     * @return null
     */
    addShapes: function(shapes) {
      var me = this;

      _.each(shapes, function(shape) {
        me.addShape(shape);
      });
    },
    /**
     * Converts an API bounds to a NPMap bounds.
     * @param {Object} bounds
     * @return {Object}
     */
    boundsFromApi: function(bounds) {
      return NPMap.Map[NPMap.config.api].boundsFromApi(bounds);
    },
    /**
     * Gets the center lat/lng of a bounds object.
     * @param {Object} bounds
     * @return {Object}
     */
    boundsGetCenter: function(bounds) {
      return {
        lat: (bounds.n + bounds.s) / 2,
        lng: (bounds.w + bounds.e) / 2
      };
    },
    /**
     * Converts a NPMap bounds to an API bounds.
     * @param {Object} bounds
     * @return {Object}
     */
    boundsToApi: function(bounds) {
      return NPMap.Map[NPMap.config.api].boundsToApi(bounds);
    },
    /**
     * Centers the map.
     * @param {Object} latLng The latLng object to center the map on.
     * @return null
     */
    center: function(latLng) {
      NPMap.Map[NPMap.config.api].center(NPMap.Map[NPMap.config.api].latLngToApi(latLng));
    },
    /**
     * Centers then zooms the map.
     * @param {Object} latLng The latLng object to center the map on.
     * @param {Number} zoom The zoom level to zoom the map to.
     * @param {Function} callback (Optional) A callback function to call after the map has been centered and zoomed.
     * @return null
     */
    centerAndZoom: function(latLng, zoom, callback) {
      NPMap.Map[NPMap.config.api].centerAndZoom(NPMap.Map[NPMap.config.api].latLngToApi(latLng), zoom, callback);
    },
    /**
     * Creates a line.
     * @param {Array} latLngs An array of the latitude/longitude objects to use to create the line.
     * @param {Object} options (Optional) Line options.
     * @return {Object}
     */
    createLine: function(latLngs, options) {
      options = options || {};

      return this._createLine(latLngs, NPMap.Map[NPMap.config.api].convertLineOptions(options));
    },
    /**
     * Creates a marker.
     * @param {Object} latLng The latitude/longitude object to use to create the marker.
     * @param {Object} options (Optional) Marker options.
     * @return {Object}
     */
    createMarker: function(latLng, options) {
      var marker,
          options = typeof options === 'object' ? NPMap.Map[NPMap.config.api].convertMarkerOptions(options) : {},
          data = options.data;

      marker = this._createMarker(latLng, options);
      marker.npmap = {
        data: data || null,
        layerName: null,
        layerType: null,
        type: 'marker'
      };

      return marker;
    },
    /**
     * Creates a polygon.
     * @param {Array} latLngs An array of latitude/longitude objects to use to create the polygon.
     * @param {Object} options (Optional) Polygon options.
     * @return {Object}
     */
    createPolygon: function(latLngs, options) {
      options = options || {};

      return this._createPolygon(latLngs, NPMap.Map[NPMap.config.api].convertPolygonOptions(options));
    },
    /**
     * UNDOCUMENTED
     */
    eventGetShape: function(e) {
      return NPMap.Map[NPMap.config.api].eventGetShape(e);
    },
    /**
     * Gets the map bounds.
     * @return {Object}
     */
    getBounds: function() {
      return this.boundsFromApi(NPMap.Map[NPMap.config.api].getBounds());
    },
    /**
     * Gets the center of the map.
     * @return {Object}
     */
    getCenter: function() {
      return this.latLngFromApi(NPMap.Map[NPMap.config.api].getCenter());
    },
    /**
     * Gets the lat/lngs of a line.
     * @param {Object} line
     * @return {Array}
     */
    getLineLatLngs: function(line) {
      var latLngs = [],
          me = this;

      _.each(NPMap.Map[NPMap.config.api].getLineLatLngs(line), function(latLng) {
        latLngs.push(me.latLngFromApi(latLng));
      });

      return latLngs;
    },
    /**
     * Gets the map element.
     * @return {Object}
     */
    getMapElement: function() {
      return NPMap.Map[NPMap.config.api].getMapElement();
    },
    /**
     * Get the lat/lng of a marker.
     * @param {Object} marker
     * @return {Object}
     */
    getMarkerLatLng: function(marker) {
      return this.latLngFromApi(NPMap.Map[NPMap.config.api].getMarkerLatLng(marker));
    },
    /**
     * UNDOCUMENTED
     */
    getMarkerOption: function(marker, option) {
      return NPMap.Map[NPMap.config.api].getMarkerOption(marker, option);
    },
    /**
     * DEPRECATED: Migrate up to getMarkerOption.
     */
    getMarkerVisibility: function(marker) {
      return NPMap.Map[NPMap.config.api].getMarkerVisibility(marker);
    },
    /**
     * Gets the maximum zoom level for the map.
     * @return {Number}
     */
    getMaxZoom: function() {
      return NPMap.Map[NPMap.config.api].getMaxZoom();
    },
    /**
     * Gets the minimum zoom level for the map.
     * @return {Number}
     */
    getMinZoom: function() {
      return NPMap.Map[NPMap.config.api].getMinZoom();
    },
    /**
     * Gets the lat/lngs of a polygon.
     * @param {Object} polygon
     * @return {Array}
     */
    getPolygonLatLngs: function(polygon) {
      var latLngs = [],
          me = this;

      _.each(NPMap.Map[NPMap.config.api].getLineLatLngs(polygon), function(latLng) {
        latLngs.push(me.latLngFromApi(latLng));
      });

      return latLngs;
    },
    /**
     * Gets the zoom level of the map.
     * @return {Number}
     */
    getZoom: function() {
      return NPMap.Map[NPMap.config.api].getZoom();
    },
    /**
     * Checks to see if a clustered layer has been added to the map.
     * @return {Boolean}
     */
    hasClusteredLayer: function() {
      hasClustered = false;

      if (typeof NPMap.Layer !== 'undefined' && typeof NPMap.Layer.iterateThroughAllLayers === 'function') {
        NPMap.Layer.iterateThroughAllLayers(function(l) {
          if (l.type === 'NativeVectors' && l.clustered === true) {
            hasClustered = true;
          }
        });
      }
      
      return hasClustered;
    },
    /**
     * Checks to see if a tiled layer has been added to the map.
     * @return {Boolean}
     */
    hasTiledLayer: function() {
      hasTiled = false;

      if (typeof NPMap.Layer !== 'undefined' && typeof NPMap.Layer.iterateThroughAllLayers === 'function') {
        NPMap.Layer.iterateThroughAllLayers(function(l) {
          if ((l.type === 'NativeVectors' && l.tiled) || (l.type === 'ArcGisServerRest' || l.type === 'CartoDb' || l.type === 'TileStream')) {
            hasTiled = true;
          }
        });
      }

      return hasTiled;
    },
    /**
     * Hides the progress bar.
     * @return null
     */
    hideProgressBar: function() {
      divProgressBar.childNodes[0].style.width = '100%';
      
      morpheus(divProgressBar, {
        complete: function() {
          divProgressBar.style.display = 'none';
          divProgressBar.style.opacity = 1;
        },
        duration: 1000,
        opacity: 0
      });
    },
    /**
     * DEPRECATED: Migrate up to setShapeOption.
     */
    hideShape: function(shape) {
      NPMap.Map[NPMap.config.api].hideShape(shape);
    },
    /**
     * Hides the tip.
     * @return null
     */
    hideTip: function() {
      if (divTip) {
        divTip.style.display = 'none';
      }
    },
    /**
     * Tests to see if a latLng is within the map's current bounds.
     * @param latLng {Object} The latitude/longitude object to test.
     * @return {Boolean}
     */
    isLatLngWithinMapBounds: function(latLng) {
      return NPMap.Map[NPMap.config.api].isLatLngWithinMapBounds(latLng);
    },
    /**
     * Tests the equivalency of two lat/lng objects.
     * @param {Object} latLng1 The first latLng object.
     * @param {Object} latLng2 The second latLng object.
     * @return {Boolean}
     */
    latLngsAreEqual: function(latLng1, latLng2) {
      var areEqual = false;

      if ((latLng1.lat.toFixed(7) === latLng2.lat.toFixed(7)) && (latLng1.lng.toFixed(7) === latLng2.lng.toFixed(7))) {
        areEqual = true;
      }

      return areEqual;
    },
    /**
     * Converts a base API lat/lng object to an NPMap lat/lng object.
     * @param {Object} latLng The lat/lng object.
     * @return {Object}
     */
    latLngFromApi: function(latLng) {
      return NPMap.Map[NPMap.config.api].latLngFromApi(latLng);
    },
    /**
     * Converts an NPMap lat/lng object to a base API latLng object.
     * @param {Object} latLng The lat/lng object.
     * @return {Object}
     */
    latLngToApi: function(latLng) {
      return NPMap.Map[NPMap.config.api].latLngToApi(latLng);
    },
    /**
     * Converts an NPMap lat/lng object to an NPMap pixel object.
     * @param {Object} latLng The lat/lng object.
     * @return {Object}
     */
    latLngToPixel: function(latLng) {
      return NPMap.Map[NPMap.config.api].latLngToPixel(this.latLngToApi(latLng));
    },
    /**
     * Turns meters into a zoom level. This function is not precise, as it is impossible to get precise meter scale values for the entire earth reprojected to web mercator.
     * @param {Number} meters
     * @return {Number}
     */
    metersToZoomLevel: function(meters) {
      var z;

      for (var i = 0; i < zoomScales.length; i++) {
        var zoom = i;
        
        if (meters >= zoomScales[i]) {
          if (zoomScales[i - 1]) {
            if (meters < zoomScales[i - 1]) {
              z = i + 1;
              break;
            }
          } else {
            z = zoom;
            break;
          }
        } else if (meters < zoomScales[zoomScales.length - 1]) {
          z = zoom;
          break;
        }
      }

      return z;
    },
    /**
     * UNDOCUMENTED
     */
    modal: function(content, okText, cancelText, okHandler, cancelHandler) {
      var buttonDiv,
          cancelButton = document.createElement('button'),
          modal = document.createElement('div'),
          okButton = document.createElement('button');

      if (divOverlay) {
        divOverlay.style.display = 'block';
      } else {
        divOverlay = document.createElement('div');
        divOverlay.className = 'npmap-modal-overlay';
        divNpmap.appendChild(divOverlay);
      }

      bean.add(cancelButton, 'click', function(e) {
        divOverlay.style.display = 'none';
        modal.parentNode.removeChild(modal);

        if (cancelHandler) {
          cancelHandler();
        }
      });
      bean.add(okButton, 'click', function(e) {
        divOverlay.style.display = 'none';
        modal.parentNode.removeChild(modal);

        if (okHandler) {
          okHandler();
        }
      });

      cancelButton.className = 'btn-simple';
      cancelButton.innerHTML = cancelText;
      okButton.className = 'btn-primary';
      okButton.innerHTML = okText;
      modal.className = 'npmap-modal';
      modal.innerHTML = '<div class="npmap-modal-content">' + content + '</div><div class="npmap-modal-buttons"></div>';
      divNpmap.appendChild(modal);
      buttonDiv = Util.getElementsByClass('npmap-modal-buttons')[0];
      buttonDiv.appendChild(okButton);
      buttonDiv.appendChild(cancelButton);
      modal.style.top = ((Util.getOuterDimensions(divNpmap).height - Util.getOuterDimensions(modal).height) / 2) + 'px';
      modal.style.display = 'block';
    },
    /**
     * Shows the notification.
     * @param {String} message
     * @param {String} title (Optional)
     * @param {String} type (Optional) Valid values are 'error', 'info', or 'success'.
     * @param {Number} interval (Optional)
     * @return null
     */
    notify: function(message, title, type, interval) {
      var msg = createNotify(message, title, type);
      
      interval = isNaN(parseInt(interval)) ? 3000 : parseInt(interval);

      if (!divNotify) {
        divNotify = document.getElementById('npmap-notify');
      }

      divNotify.appendChild(msg);

      if (Util.getOuterDimensions(divNotify).height === 0) {
        msg.style.top = -Util.getOuterDimensions(msg).height + 'px';
        morpheus(msg, {
          complete: function() {
            msg.style.position = 'relative';
            msg.style.top = 'inherit';
            setTimeout(function() {
              msg.parentNode.removeChild(msg);
            }, interval);
          },
          duration: 400,
          top: '0px'
        });
      } else {
        msg.style.position = 'relative';
        msg.style.top = 'inherit';
        setTimeout(function() {
          msg.parentNode.removeChild(msg);
        }, interval);
      }
    },
    /**
     * Pans the map horizontally and/or vertically based on the pixel object passed in.
     * @param {Object} pixel
     * @param {Function} callback (Optional)
     * @return null
     */
    panByPixels: function(pixel, callback) {
      NPMap.Map[NPMap.config.api].panByPixels(pixel, callback);
    },
    /**
     * Pans the map in a direction by a quarter of the current map viewport.
     * @param {String} direction The direction to pan the map in. Valid directions are 'east', 'north', 'south', and 'west'.
     * @return null
     */
    panInDirection: function(direction) {
      var divMapDimensions = Util.getOuterDimensions(divMap),
          h = divMapDimensions.height,
          me = this,
          w = divMapDimensions.width;

      switch (direction) {
        case 'east':
          me.panByPixels({
            x: - (w / 4),
            y: 0
          });
          break;
        case 'north':
          me.panByPixels({
            x: 0,
            y: h / 4
          });
          break;
        case 'south':
          me.panByPixels({
            x: 0,
            y: - (h / 4)
          });
          break;
        case 'west':
          me.panByPixels({
            x: w / 4,
            y: 0
          });
          break;
      }
    },
    /**
     * Converts a base API pixel object to its NPMap equivalent.
     * @param {Object} pixel
     * @return {Object}
     */
    pixelFromApi: function(pixel) {
      return NPMap.Map[NPMap.config.api].pixelFromApi(pixel);
    },
    /**
     * Converts an NPMap pixel object to its base API equivalent.
     * @param {Object} pixel
     * @return {Object}
     */
    pixelToApi: function(pixel) {
      return NPMap.Map[NPMap.config.api].pixelToApi(pixel);
    },
    /**
     * Converts an NPMap pixel object to an NPMap lat/lng object.
     * @param {Object} pixel
     * @return {Object}
     */
    pixelToLatLng: function(pixel) {
      return NPMap.Map[NPMap.config.api].latLngFromApi(NPMap.Map[NPMap.config.api].pixelToLatLng(NPMap.Map[NPMap.config.api].pixelToApi(pixel)));
    },
    /**
     * Removes a shape from the map.
     * @param {Object} shape The shape to remove from the map.
     * @return null
     */
    removeShape: function(shape) {
      NPMap.Map[NPMap.config.api].removeShape(shape);
    },
    /**
     * Sets the map bounds.
     * @param {Object} bounds
     * @return null
     */
    setBounds: function(bounds) {
      NPMap.Map[NPMap.config.api].setBounds(bounds);
    },
    /**
     * Sets the map cursor.
     * @param {String} cursor
     * @return null
     */
    setCursor: function(cursor) {
      if (typeof NPMap.Map[NPMap.config.api].setCursor === 'function') {
        NPMap.Map[NPMap.config.api].setCursor(cursor);
      } else {
        var div = this.getMapElement();

        if (div.style.cursor) {
          div.style.cursor.replace(/cursor:[^;]+/g, '');
        }

        div.style.cursor = cursor;
      }
    },
    /**
     * Sets the initial center of the map. This initial center is stored with the map, and is used by the setInitialExtent method, among other things.
     * @param {Object} center
     * @return null
     */
    setInitialCenter: function(center) {
      NPMap.Map[NPMap.config.api].setInitialCenter(this.latLngToApi(center));
    },
    /**
     * Sets the initial zoom of the map. This initial zoom is stored with the map, and is used by the setInitialExtent method, among other things.
     * @param {Number} zoom
     * @return null
     */
    setInitialZoom: function(zoom) {
      NPMap.Map[NPMap.config.api].setInitialZoom(zoom);
    },
    /**
     * UNDOCUMENTED
     */
    setLayerOptions: function(config, options) {
      var func = Layer[config.type]._setOptions;

      if (typeof options !== 'object') {
        throw new Error('The options parameter must be an object.');
      }

      if (func) {
        func(config, options);
      }
    },
    /**
     * Sets a marker's options.
     * @param {Object} marker The baseApi marker object.
     * @param {Object} options The options to set. Currently the valid options are: 'class', 'icon', 'label', 'visible', and 'zIndex'.
     * @return null
     */
    setMarkerOptions: function(marker, options) {
      NPMap.Map[NPMap.config.api].setMarkerOptions(marker, options);
    },
    /**
     * Sets the notify target to an HTML element other than the map div. This can only be called after NPMap has been initialized.
     * @param {Object} el
     * @return null
     */
    setNotifyTarget: function(el) {
      if (!divNotify) {
        divNotify = document.getElementById('npmap-notify');
      }

      el.appendChild(divNotify);
    },
    /**
     * Sets min and/or max zoom restrictions on the map.
     * @param {Object} restrictions
     * @return null
     */
    setZoomRestrictions: function(restrictions) {
      NPMap.Map[NPMap.config.api].setZoomRestrictions(restrictions);
    },
    /**
     * Shows the progress bar.
     * @param {Number} value (Optional) The value to start the progress bar at.
     * @return null
     */
    showProgressBar: function(value) {
      if (!divProgressBar) {
        divProgressBar = document.getElementById('npmap-progressbar');
      }

      divProgressBar.style.display = 'block';

      if (!value) {
        value = 0;
      }

      this.updateProgressBar(value);
    },
    /**
     * Shows a shape.
     * @param {Object} shape The shape to show.
     * @return null
     */
    showShape: function(shape) {
      NPMap.Map[NPMap.config.api].showShape(shape);
    },
    /**
     * Shows the tip.
     * @param {String} content
     * @param {Object} position
     * @return null
     */
    showTip: function(content, position) {
      var dimensions = Util.getOuterDimensions(divMap);

      if (!divTip) {
        divTip = document.getElementById('npmap-tip');
      }

      divTip.innerHTML = content;
      divTip.style.bottom = (dimensions.height - position.y) + 'px';
      divTip.style.right = (dimensions.width - position.x) + 'px';
      divTip.style.display = 'block';
    },
    /**
     * Zooms the map to a bounding box.
     * @param {Object} bounds
     * @return null
     */
    toBounds: function(bounds) {
      NPMap.Map[NPMap.config.api].toBounds(NPMap.Map[NPMap.config.api].boundsToApi(bounds));
    },
    /**
     * Toggles fullscreen mode on or off.
     * @return null
     */
    toggleFullScreen: function() {
      var baseApi = NPMap.Map[NPMap.config.api],
          currentCenter = baseApi.getCenter(),
          currentZoom = baseApi.getZoom(),
          divNpmap = document.getElementById('npmap');

      /*
      if (el.requestFullScreen || el.mozRequestFullScreen || el.webkitRequestFullScreen) {
        document.onfullscreenchange = function(e) {
          if (document.fullScreenElement || document.mozFullScreenElement || document.webkitFullScreenElement) {
            isFullScreen = true;
          } else {
            isFullScreen = false;
          }
        };

        if (isFullScreen) {
          if (el.cancelFullScreen) {
            el.cancelFullScreen();
          } else if (el.mozCancelFullScreen) {
            el.mozCancelFullScreen();
          } else {
            document.webkitCancelFullScreen();
          }

          isFullScreen = false;
        } else {
          if (el.requestFullScreen) {
            el.requestFullScreen();
          } else if (el.mozRequestFullScreen) {
            el.mozRequestFullScreen();
          } else {
            el.webkitRequestFullScreen();
          }

          isFullScreen = true;
        }
      } else {
      */
        var dimensionsWindow = Util.getWindowDimensions(),
            divMask = document.getElementById('npmap-fullscreen-mask');
        
        if (NPMap.InfoBox.visible) {
          currentCenter = baseApi.latLngToApi(NPMap.InfoBox.latLng);
        }

        Event.add('NPMap.Map', 'resized', function() {
          baseApi.centerAndZoom(currentCenter, currentZoom);
        }, true);

        if (isFullScreen) {
          document.body.style.overflow = 'visible';

          Util.removeClass(divNpmap, 'npmap-fullscreen-map');

          divNpmap.style.height = '100%';
          divNpmap.style.width = '100%';
          divMap.style.position = 'absolute';

          divNpmapParent.appendChild(divNpmap);

          divMask.style.display = 'none';
          document.getElementById('npmap-infobox').style.zIndex = '30';
          isFullScreen = false;
        } else {
          if (!divMask) {
            var div = document.createElement('div');
            div.id = 'npmap-fullscreen-mask';
            document.body.appendChild(div);
            divMask = document.getElementById('npmap-fullscreen-mask');
          }
          
          document.body.style.overflow = 'hidden';
          divMask.style.display = 'block';
          
          Util.addClass(divNpmap, 'npmap-fullscreen-map');
          divNpmap.style.height = dimensionsWindow.height + 'px';
          divNpmap.style.width = dimensionsWindow.width + 'px';
          divMap.style.position = 'fixed';

          divMask.appendChild(divNpmap);

          document.getElementById('npmap-infobox').style.zIndex = '99999999999999';
          isFullScreen = true;
        }

        // TODO: Need to look into why this isn't being triggered properly.
        if (NPMap.config.api === 'ModestMaps') {
          Event.trigger('NPMap.Map', 'resized');
        }
      /*
      }
      */
    },
    /**
     * Zooms and/or pans the map to its initial extent.
     * @return null
     */
    toInitialExtent: function() {
      NPMap.Map[NPMap.config.api].toInitialExtent();
    },
    /**
     * Zooms the map to the extent of an array of lat/lng objects.
     * @param {Array} latLngs The array of lat/lng objects.
     * @param {Number} zoom (Optional) The zoom level to zoom the map to.
     * @return null
     */
    toLatLngs: function(latLngs, zoom) {
      var first = latLngs[0],
          bounds = {
            e: first.lng,
            n: first.lat,
            s: first.lat,
            w: first.lng
          };

      _.each(latLngs, function(latLng) {
        if (latLng.lat > bounds.n) {
          bounds.n = latLng.lat;
        }

        if (latLng.lat < bounds.s) {
          bounds.s = latLng.lat;
        }

        if (latLng.lng > bounds.e) {
          bounds.e = latLng.lng;
        }

        if (latLng.lng < bounds.w) {
          bounds.w = latLng.lng;
        }
      });
      
      if (zoom) {
        this.centerAndZoom(this.boundsGetCenter(bounds), zoom);
      } else {
        this.toBounds(bounds);
      }
    },
    /**
     * DEPRECATED
     */
    toMarkers: function(markers) {
      NPMap.Map[NPMap.config.api].toMarkers(markers);
    },
    /**
     * Zooms the map to the extent of an array of shapes (markers, lines, and polygons).
     * @param {Array} shapes
     * @return null
     */
    toShapes: function(shapes) {
      var latLngs = [],
          me = this;

      _.each(shapes, function(shape) {
        switch (shape.npmap.type) {
          case 'Line':
            latLngs.push(me.getLineLatLngs(shape));
            break;
          case 'Marker':
            latLngs.push(me.getMarkerLatLng(shape));
            break;
          case 'Polygon':
            latLngs.push(me.getPolygonLatLngs(shape));
            break;
        }
      });

      this.toLatLngs(_.flatten(latLngs));
    },
    /**
     * Updates the progress bar value.
     * @param {Number} value The value to update the progress bar with.
     * @return null;
     */
    updateProgressBar: function(value) {
      divProgressBar.childNodes[0].style.width = value + '%';
    },
    /**
     * Zooms the map to a zoom level.
     * @param {Number} zoom
     * @return null
     */
    zoom: function(zoom) {
      NPMap.Map[NPMap.config.api].zoom(zoom);
    },
    /**
     * Zooms the map in by one zoom level.
     * @return null
     */
    zoomIn: function() {
      NPMap.Map[NPMap.config.api].zoomIn();
    },
    /**
     * Zooms the map out by one zoom level.
     * @return null
     */
    zoomOut: function() {
      NPMap.Map[NPMap.config.api].zoomOut();
    }
  };
});